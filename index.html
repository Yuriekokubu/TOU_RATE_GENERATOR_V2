<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤ (Neumorphism)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="./holiday_results/holiday_2022.js"></script>
    <script src="./holiday_results/holiday_2023.js"></script>
    <script src="./holiday_results/holiday_2024.js"></script>
    <script src="./holiday_results/holiday_2025.js"></script>
</head>

<body>
    <div class="container">
        <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel</h1>

        <div id="dropArea" class="drop-area">
            <span class="icon">üìÑ</span>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
            <p>‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <input type="file" id="excelFile" accept=".xlsx, .xls">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthYearSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô:</label>
                <div class="select-wrapper">
                    <select id="monthYearSelector" onchange="updateDisplay()">
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="arTypeSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR:</label>
                <div class="select-wrapper">
                    <select id="arTypeSelector" onchange="updateDisplay()">
                        <option value="AR1">AR1</option>
                        <option value="AR6">AR6</option>
                        <option value="HA1">HA1</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="unitSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢:</label>
                <div class="select-wrapper">
                    <select id="unitSelector" onchange="updateDisplay()">
                        <option value="kwh_kvarh">kWh, kVarh</option>
                        <option value="kw_kvar">kW, kVar</option>
                    </select>
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="applyMultiplier" onchange="updateDisplay()">
                <label for="applyMultiplier" class="custom-checkbox">
                    ‡∏Ñ‡∏π‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì
                    <span class="icon-checked">‚úî</span> <span class="icon-unchecked"></span> </label>
            </div>

            <div class="control-group">
                <button id="exportExcel" class="button">Export Data to Excel</button>
            </div>
        </div>

        <div id="output"></div>
    </div>

    <script>
        const holidays = new Set();
        let globalResults = [];
        let isProcessed = false; // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå
        let meterNumber = '';
        let multiplier = 0;

        let sortState = {
            columnIndex: null,
            direction: 'asc'
        };

        const dropArea = document.getElementById('dropArea');
        const excelFileInput = document.getElementById('excelFile');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('drag-over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('drag-over'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï isProcessed ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà
                isProcessed = false;
                excelFileInput.files = files;
                process();
            }
        }

        dropArea.addEventListener('click', () => {
            excelFileInput.click();
        });

        excelFileInput.addEventListener('change', () => {
            if (excelFileInput.files.length > 0) {
                // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï isProcessed ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà
                isProcessed = false;
                process();
            }
        });

        // Helper function to extract BKK time components from a UTC-adjusted Date object.
        // It assumes the input utcDateObj has already been adjusted to reflect BKK time
        // in its UTC components.
        function getBKKTimeComponents(utcDateObj) {
            return {
                hour: utcDateObj.getUTCHours(),
                minute: utcDateObj.getUTCMinutes(),
                second: utcDateObj.getUTCSeconds(),
                day: utcDateObj.getUTCDate(),
                month: utcDateObj.getUTCMonth(), // 0-indexed
                year: utcDateObj.getUTCFullYear(),
                dayOfWeek: utcDateObj.getUTCDay() // BKK day of week (0=Sun, 6=Sat)
            };
        }

        // Helper function to get a Date object representing midnight of a calendar day in BKK timezone.
        // The returned Date object's UTC components will *directly* represent BKK midnight.
        function getBKKMidnightUTCAdjusted(year, monthIndex, day) { // monthIndex is 0-indexed
            // Create a Date object where its UTC components directly represent BKK midnight for the given day.
            const d = new Date(Date.UTC(year, monthIndex, day, 0, 0, 0));
            return d;
        }

        // ******** ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á Excel Date ‡πÄ‡∏õ‡πá‡∏ô BKK Time ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö UTC-adjusted (‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö) ********
        function convertExcelDateToBKKUTCAdjusted(rawDate) {
            let dateObj;
            const bkkOffsetMs = 7 * 60 * 60 * 1000; // 7 hours in milliseconds

            if (rawDate instanceof Date) {
                // ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô Date object ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏≠‡∏≤‡∏à‡∏°‡∏≤‡∏à‡∏≤‡∏Å cellDates: true)
                // Date object ‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢ XLSX library ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡πâ‡∏≠‡∏á‡∏ñ‡∏¥‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå
                // ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ UTC components ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô BKK Time
                // ‡∏à‡∏∂‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° offset ‡∏Ç‡∏≠‡∏á BKK (7 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á) ‡πÑ‡∏õ‡∏ó‡∏µ‡πà timestamp ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                dateObj = new Date(rawDate.getTime() + bkkOffsetMs);
            } else if (typeof rawDate === 'number') {
                // ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏à‡∏≤‡∏Å Excel (serial date)
                const parsed = XLSX.SSF.parse_date_code(rawDate);
                // XLSX.SSF.parse_date_code ‡∏à‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô y, m, d, H, M, S ‡∏ó‡∏µ‡πà "‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏≤‡∏á" (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô UTC ‡∏´‡∏£‡∏∑‡∏≠ Local)
                // ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ BKK Time ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Date.UTC() ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                // ‡∏ó‡∏≥‡πÉ‡∏´‡πâ UTC components ‡∏Ç‡∏≠‡∏á dateObj ‡πÅ‡∏ó‡∏ô BKK Time ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                dateObj = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H, parsed.M, parsed.S));
            } else if (typeof rawDate === 'string') {
                // ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô String
                const match = rawDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s*(\d{1,2}):(\d{2}):(\d{2})|(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{2}):(\d{2})/);
                if (match) {
                    let year, month, day, hour, minute, second;
                    if (match[1]) { // DD/MM/YYYY HH:mm:ss format
                        [, day, month, year, hour, minute, second] = match;
                        year = parseInt(year) > 2500 ? parseInt(year) - 543 : parseInt(year); // Convert Buddhist year to AD
                    } else if (match[7]) { // YYYY-MM-DDTHH:mm:ss format
                        [, , , , , , year, month, day, hour, minute, second] = match;
                    }
                    // ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤ string components ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ BKK Time ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Date.UTC() ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                    dateObj = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                } else {
                    // ‡∏Å‡∏£‡∏ì‡∏µ string format ‡∏≠‡∏∑‡πà‡∏ô‡πÜ (‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô ISO 8601 ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ Z ‡∏´‡∏£‡∏∑‡∏≠ Time Zone offset)
                    // ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡πâ Date constructor ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ ‡∏ã‡∏∂‡πà‡∏á‡∏°‡∏±‡∏Å‡∏à‡∏∞‡∏ï‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô Local Time ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö
                    let tempDate = new Date(rawDate);
                    if (!isNaN(tempDate.getTime())) { // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ parse ‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á
                        // ‡πÄ‡∏û‡∏¥‡πà‡∏° offset ‡∏Ç‡∏≠‡∏á BKK (7 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á) ‡πÑ‡∏õ‡∏ó‡∏µ‡πà timestamp ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                        dateObj = new Date(tempDate.getTime() + bkkOffsetMs);
                    } else {
                        return null; // parse ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
                    }
                }
            } else {
                return null; // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
            }

            return isNaN(dateObj.getTime()) ? null : dateObj;
        }
        // ******************************************************************************

        function collectHolidays() {
            holidays.clear();
            const allHolidayVars = [
                typeof holiday_2022 !== 'undefined' ? holiday_2022 : null,
                typeof holiday_2023 !== 'undefined' ? holiday_2023 : null,
                typeof holiday_2024 !== 'undefined' ? holiday_2024 : null,
                typeof holiday_2025 !== 'undefined' ? holiday_2025 : null
            ];
            allHolidayVars.forEach(data => {
                if (!data || !data.data) return;
                data.data.forEach(entry => {
                    if (entry.tou === 1 && entry.holiday) {
                        const [d, m, byear] = entry.holiday.split('/');
                        const year = parseInt(byear) - 543;

                        // Create a Date object representing the holiday at midnight in BKK timezone (UTC components match BKK)
                        const bkkHolidayMidnight = getBKKMidnightUTCAdjusted(year, parseInt(m) - 1, parseInt(d));

                        // Store its ISO string (which will correctly be YYYY-MM-DD from UTC components matching BKK)
                        const isoDate = bkkHolidayMidnight.toISOString().split('T')[0];
                        holidays.add(isoDate);
                    }
                });
            });
        }

        function isHoliday(date) {
            // date is a UTC-adjusted Date object (its UTC components reflect BKK time)
            let checkDate = new Date(date.getTime()); // Create a copy to avoid modifying original

            const bkkComponents = getBKKTimeComponents(checkDate); // Get BKK components from the UTC-adjusted date
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                // If the BKK time is between 00:00 and 00:14,
                // adjust the date backwards by one BKK day (by adjusting UTC components).
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
            }

            // Convert to YYYY-MM-DD for holiday set lookup
            const finalBkkComponents = getBKKTimeComponents(checkDate);
            const iso = finalBkkComponents.year + '-' +
                String(finalBkkComponents.month + 1).padStart(2, '0') + '-' +
                String(finalBkkComponents.day).padStart(2, '0');
            return holidays.has(iso);
        }

        function getRate(date) {
            // date is a UTC-adjusted Date object (its UTC components reflect BKK time)
            let checkDate = new Date(date.getTime()); // Create a copy to avoid modifying original

            const bkkComponents = getBKKTimeComponents(checkDate); // Get BKK components from the UTC-adjusted date
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            // If time is 00:00 to 00:14, consider it part of the previous day
            if (hour === 0 && min < 15) {
                // Adjust the date backwards by one BKK day for rate calculation
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
                // Re-calculate hour/min from the adjusted date for rate logic
                const adjustedBkkComponents = getBKKTimeComponents(checkDate);
                hour = adjustedBkkComponents.hour;
                min = adjustedBkkComponents.minute;
            }

            const day = getBKKTimeComponents(checkDate).dayOfWeek; // Get BKK day of week (0=‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå, 6=‡πÄ‡∏™‡∏≤‡∏£‡πå)
            if (isHoliday(date) || day === 0 || day === 6) {
                return 'Holiday';
            }

            const totalMin = hour * 60 + min;
            const peakStart = 9 * 60 + 15; // 09:15
            const peakEnd = 22 * 60; // 22:00

            if (totalMin >= peakStart && totalMin <= peakEnd) {
                return 'Peak';
            } else {
                return 'Off-peak';
            }
        }

        // Helper function to get the number of days in a month
        // month is 1-indexed (1=Jan, 12=Dec)
        function getDaysInMonth(year, month) {
            // month + 1 as new Date(year, month, 0) gives last day of previous month for 0-indexed month
            // So, new Date(year, month, 0) will give the last day of the 'month' parameter
            return new Date(Date.UTC(year, month, 0)).getUTCDate();
        }


        // Modified getReadingDay to calculate based on days in month
        function getReadingDay(year, month, arType) { // month is 1-indexed here (1-12)
            const numDaysInMonth = getDaysInMonth(year, month); // Get days for the given month

            if (arType === 'AR1') {
                // If the month has 31 days -> 31 - 10 = 21
                // If the month has 30 days -> 30 - 10 = 20
                // If the month has 28 days (Feb) -> 28 - 10 = 18
                // If the month has 29 days (Leap Feb) -> 29 - 10 = 19
                return numDaysInMonth - 10;
            } else if (arType === 'AR6') {
                // If the month has 31 days -> 31 - 2 = 29
                // If the month has 30 days -> 30 - 2 = 28
                // If the month has 28 days (Feb) -> 28 - 2 = 26
                // If the month has 29 days (Leap Feb) -> 29 - 2 = 27
                return numDaysInMonth - 2;
            } else if (arType === 'HA1') {
                return 1; // Fixed to 1st of the month
            }
            console.error(`[getReadingDay] Unknown AR Type: ${arType}`);
            return -1; // Should not happen
        }

        function isInBillingPeriod(dateObject, arType, selectedMonth, selectedYear) {
            // dateObject is `roundedDateObjectUTC`, which has its UTC components
            // already adjusted to represent BKK time.

            let billingPeriodStartDate, billingPeriodEndDate;

            // Determine the month and year for the *previous* reading
            let prevReadingMonth = selectedMonth - 1; // 1-indexed month
            let prevReadingYear = selectedYear;
            if (prevReadingMonth === 0) { // If current month is January, previous is December of last year
                prevReadingMonth = 12;
                prevReadingYear--;
            }

            // Determine the reading day for the previous month based on its number of days
            const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
            if (prevReadingDay === -1) {
                console.warn(`[isInBillingPeriod] Could not determine prevReadingDay for ${prevReadingYear}-${prevReadingMonth}`);
                return false;
            }

            // Calculate the start date of the billing period
            // It's the previous month's reading date at 00:15:00 BKK (UTC components match BKK)
            billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay); // monthIndex is 0-indexed for getBKKMidnightUTCAdjusted
            billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


            // Determine the reading day for the *current* billing month based on its number of days
            const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
            if (currentReadingDay === -1) {
                console.warn(`[isInBillingPeriod] Could not determine currentReadingDay for ${selectedYear}-${selectedMonth}`);
                return false;
            }

            // Calculate the end date of the billing period
            // It's the current month's reading date at 00:00:00 BKK (of the *next* day) (UTC components match BKK)
            // This ensures data up to 24:00:00 (which is 00:00:00 of the next day) of the reading day is included.
            billingPeriodEndDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay); // monthIndex is 0-indexed

            // LOG: Check calculated startDate and endDate.
            // console.log(`[isInBillingPeriod] Comparing: Date: ${dateObject.toISOString()} vs Start: ${billingPeriodStartDate.toISOString()} End: ${billingPeriodEndDate.toISOString()}`);

            // CHANGE: Changed from < to <= to include the exact 00:00:00 of the next day.
            return dateObject.getTime() >= billingPeriodStartDate.getTime() && dateObject.getTime() <= billingPeriodEndDate.getTime();
        }

        function sortTable(columnIndex) {
            if (!isProcessed) return;

            if (sortState.columnIndex === columnIndex) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.columnIndex = columnIndex;
                if (columnIndex === 0) { // Datetime
                    sortState.direction = 'asc';
                } else if (columnIndex === 1) { // Rate
                    sortState.direction = 'asc';
                } else { // Numeric columns
                    sortState.direction = 'desc';
                }
            }

            updateDisplay(); // Re-render the detailed table after sorting
        }

        function customRound(value, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces);
            return Math.round(value * factor) / factor;
        }


        // Modified renderResults to accept selectedMonthYear and selectedArType
        function renderResults(unitType, selectedMonthYear, selectedArType) {
            if (!isProcessed) return;

            let whUnit, varhUnit;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;

            let whCalculation, varhCalculation;
            let decimalPlacesForSummary; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡πà‡∏≤ kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞ kWh/kVarh ‡∏£‡∏ß‡∏°
            const decimalPlacesForKwKvarTable = 6; // *** NEW: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kVar ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á 6 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ***

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlacesForSummary = 3; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡∏∏‡∏õ kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á 3 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

                // whCalculation ‡πÅ‡∏•‡∏∞ varhCalculation ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏à‡∏£‡∏¥‡∏á
                // ‡∏Å‡∏≤‡∏£‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ
                whCalculation = (wh_val) => {
                    let baseKw = (parseFloat(wh_val) * 4 / 1000);
                    if (applyMultiplier) {
                        return baseKw * currentMultiplier;
                    }
                    return baseKw;
                };
                varhCalculation = (varh_val) => {
                    let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                    if (applyMultiplier) {
                        return baseKvar * currentMultiplier;
                    }
                    return baseKvar;
                };
            } else { // kWh, kVarh
                whUnit = 'kWh';
                varhUnit = 'kVarh';
                decimalPlacesForSummary = 2; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kWh/kVarh ‡∏£‡∏ß‡∏° ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

                whCalculation = (wh_val) => {
                    const raw = (parseFloat(wh_val) / 1000);
                    const valueToRound = raw * currentMultiplier;
                    return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                };

                varhCalculation = (varh_val) => {
                    const raw = (parseFloat(varh_val) / 1000);
                    const valueToRound = raw * currentMultiplier;
                    return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                };
            }

            let tableRowsHtml = '';

            // --- START: New variables to track MAX RAW values and their datetimes ---
            // These will ONLY store the raw WH/VARHIMP Total values
            let maxRawWhValues = {
                'Peak': { value: 0, datetime: '' },
                'Off-peak': { value: 0, datetime: '' },
                'Holiday': { value: 0, datetime: '' }
            };
            let maxRawVarhValues = {
                'Peak': { value: 0, datetime: '' },
                'Off-peak': { value: 0, datetime: '' },
                'Holiday': { value: 0, datetime: '' }
            };
            let overallMaxRawWh = { value: 0, datetime: '' };
            let overallMaxRawVarh = { value: 0, datetime: '' };
            // --- END: New variables to track MAX RAW values and their datetimes ---


            // New summary variables for total consumption (these accumulate already processed values)
            let totalWhConsumption = {
                'Peak': 0,
                'Off-peak': 0,
                'Holiday': 0
            };
            let totalVarhConsumption = {
                'Peak': 0,
                'Off-peak': 0,
                'Holiday': 0
            };

            let filteredResults = [];
            if (selectedMonthYear === 'all') { // If "All Data" is selected for month/year
                filteredResults = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                filteredResults = globalResults.filter(r => {
                    // Filter by selected AR Type explicitly and by selected Month/Year
                    const isWithinBillingPeriod = isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                    return isWithinBillingPeriod;
                });
            }

            // Apply sorting to filteredResults
            const dataToRender = [...filteredResults]; // Clone for sorting
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Sort kW/kVar ‡πÄ‡∏£‡∏≤‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (‡πÑ‡∏°‡πà‡∏õ‡∏±‡∏î‡∏ó‡∏¥‡πâ‡∏á) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                    // ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
                    whUnitConverterForSort = (wh_val) => {
                        let baseKw = (parseFloat(wh_val) * 4 / 1000);
                        if (applyMultiplierForSort) return baseKw * currentMultiplierForSort;
                        return baseKw;
                    };
                    varhUnitConverterForSort = (varh_val) => {
                        let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                        if (applyMultiplierForSort) return baseKvar * currentMultiplierForSort;
                        return baseKvar;
                    };
                } else { // kWh/kVarh ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Sort ‡πÉ‡∏´‡πâ‡∏õ‡∏±‡∏î‡∏ï‡∏≤‡∏° decimalPlacesForSummary
                    whUnitConverterForSort = (wh_val) => {
                        const raw = (parseFloat(wh_val) / 1000);
                        const valueToRound = raw * currentMultiplierForSort;
                        return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                    };
                    varhUnitConverterForSort = (varh_val) => {
                        const raw = (parseFloat(varh_val) / 1000);
                        const valueToRound = raw * currentMultiplierForSort;
                        return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                    };
                }

                dataToRender.sort((a, b) => {
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataToRender.forEach(r => {
                const rawWh = r.originalWhValue || 0; // Use rawWh directly for max comparison
                const rawVarh = r.originalVarhValue || 0; // Use rawVarh directly for max comparison

                const rate = getRate(r.dateObject);

                // --- START: Update MAX RAW values (STRICTLY RAW) ---
                if (unitType === 'kw_kvar') {
                    if (rawWh > maxRawWhValues[rate].value) {
                        maxRawWhValues[rate].value = rawWh;
                        maxRawWhValues[rate].datetime = r.datetime;
                    }
                    if (rawVarh > maxRawVarhValues[rate].value) {
                        maxRawVarhValues[rate].value = rawVarh;
                        maxRawVarhValues[rate].datetime = r.datetime;
                    }

                    if (rawWh > overallMaxRawWh.value) {
                        overallMaxRawWh.value = rawWh;
                        overallMaxRawWh.datetime = r.datetime;
                    }
                    if (rawVarh > overallMaxRawVarh.value) {
                        overallMaxRawVarh.value = rawVarh;
                        overallMaxRawVarh.datetime = r.datetime;
                    }
                }
                // --- END: Update MAX RAW values ---


                // Calculate currentWh and currentVarh for individual table display
                const currentWh = whCalculation(rawWh); // Pass rawWh to calculation
                const currentVarh = varhCalculation(rawVarh); // Pass rawVarh to calculation

                // --- HERE IS THE KEY CHANGE FOR TABLE DISPLAY ---
                let displayWhInTable, displayVarhInTable;
                if (unitType === 'kw_kvar') {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kVar ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏õ‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô 6 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    displayWhInTable = currentWh.toFixed(decimalPlacesForKwKvarTable);
                    displayVarhInTable = currentVarh.toFixed(decimalPlacesForKwKvarTable);
                } else {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kWh/kVarh ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏õ‡∏±‡∏î‡∏ï‡∏≤‡∏° decimalPlacesForSummary (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∑‡∏≠ 2)
                    displayWhInTable = currentWh.toFixed(decimalPlacesForSummary);
                    displayVarhInTable = currentVarh.toFixed(decimalPlacesForSummary);
                }

                // Update total consumption (these are already calculated with multiplier if checked)
                totalWhConsumption[rate] += currentWh;
                totalVarhConsumption[rate] += currentVarh;


                let displayDatetime = r.datetime; // This is already formatted from process()
                const cls = rate.toLowerCase().replace('-', '');
                tableRowsHtml += `<tr class="${cls}">
            <td>${displayDatetime}</td><td>${rate}</td>
            <td>${displayWhInTable}</td><td>${displayVarhInTable}</td>
        </tr>`;
            });

            const formattedMultiplier = multiplier.toLocaleString('en-US', {
                minimumFractionDigits: 4,
                maximumFractionDigits: 4
            });

            let meterInfoHtml = `
        <div class="summary-box meter-info">
            <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</h3>
            <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå: <strong>${meterNumber || 'N/A'}</strong></p>
            <p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì: <strong>${formattedMultiplier}</strong></p>
        </div>`;

            let mainSummaryHtml = '';

            // Start of Rate Summary Container
            mainSummaryHtml += '<div class="rate-summary-container">';

            // Max kW/kVar Summary (if unitType is kw_kvar)
            if (unitType === 'kw_kvar') {
                // --- START: Calculate final kW/kVar for display using max RAW values ---
                // ONLY HERE DO WE APPLY whCalculation/varhCalculation TO THE MAX RAW VALUES
                // ‡πÅ‡∏•‡∏∞‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡∏ï‡∏≤‡∏° decimalPlacesForSummary (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∑‡∏≠ 3)
                const displayOverallMaxKw = whCalculation(overallMaxRawWh.value).toFixed(decimalPlacesForSummary);
                const displayOverallMaxKvar = varhCalculation(overallMaxRawVarh.value).toFixed(decimalPlacesForSummary);

                const displayPeakMaxKw = whCalculation(maxRawWhValues['Peak'].value).toFixed(decimalPlacesForSummary);
                const displayPeakMaxKvar = varhCalculation(maxRawVarhValues['Peak'].value).toFixed(decimalPlacesForSummary);

                const displayOffPeakMaxKw = whCalculation(maxRawWhValues['Off-peak'].value).toFixed(decimalPlacesForSummary);
                const displayOffPeakMaxKvar = varhCalculation(maxRawVarhValues['Off-peak'].value).toFixed(decimalPlacesForSummary);

                const displayHolidayMaxKw = whCalculation(maxRawWhValues['Holiday'].value).toFixed(decimalPlacesForSummary);
                const displayHolidayMaxKvar = varhCalculation(maxRawVarhValues['Holiday'].value).toFixed(decimalPlacesForSummary);
                // --- END: Calculate final kW/kVar for display using max RAW values ---


                mainSummaryHtml += `
            <div class="summary-box overall-max-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó</h3>
                <p>kW: <strong>${displayOverallMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxRawWh.datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOverallMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxRawVarh.datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-peak-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Peak)</h3>
                <p>kW: <strong>${displayPeakMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawWhValues['Peak'].datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayPeakMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawVarhValues['Peak'].datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-off-peak-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Off-peak)</h3>
                <p>kW: <strong>${displayOffPeakMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawWhValues['Off-peak'].datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOffPeakMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawVarhValues['Off-peak'].datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-holiday-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Holiday)</h3>
                <p>kW: <strong>${displayHolidayMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawWhValues['Holiday'].datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayHolidayMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawVarhValues['Holiday'].datetime || 'N/A'}</small></p>
            </div>
        `;
            }

            // Total Consumption Summary (for both kWh/kVarh and kW/kVar units, but values change)
            // This block will only be added if unitType is 'kwh_kvarh'
            if (unitType === 'kwh_kvarh') {
                mainSummaryHtml += `
            <div class="summary-box consumption-summary">
                <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô (‡∏£‡∏ß‡∏°)</h3>
                <p>‡∏£‡∏ß‡∏° Peak: <strong>${totalWhConsumption['Peak'].toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Peak'].toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
                <p>‡∏£‡∏ß‡∏° Off-peak: <strong>${totalWhConsumption['Off-peak'].toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Off-peak'].toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
                <p>‡∏£‡∏ß‡∏° Holiday: <strong>${totalWhConsumption['Holiday'].toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Holiday'].toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
                <p class="total-overall">‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: <strong>${(totalWhConsumption['Peak'] + totalWhConsumption['Off-peak'] + totalWhConsumption['Holiday']).toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${(totalVarhConsumption['Peak'] + totalVarhConsumption['Off-peak'] + totalVarhConsumption['Holiday']).toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
            </div>
        `;
            }

            mainSummaryHtml += '</div>'; // End of Rate Summary Container

            const headers = [{
                title: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤',
                index: 0
            }, {
                title: '‡πÄ‡∏£‡∏ó',
                index: 1
            }, {
                title: whUnit,
                index: 2
            }, {
                title: varhUnit,
                index: 3
            }];

            const headerHtml = headers.map(h => {
                const isActiveSort = sortState.columnIndex !== null && sortState.columnIndex === h.index;
                const sortClass = isActiveSort ? `active-sort ${sortState.direction}` : '';
                return `<th class="sortable ${sortClass}" onclick="sortTable(${h.index})" data-column-index="${h.index}">
                        ${h.title} <span class="sort-indicator"></span>
                    </th>`;
            }).join('');

            let tableHtml = `<table><tr>${headerHtml}</tr>${tableRowsHtml}</table>`;

            document.getElementById('output').innerHTML = meterInfoHtml + mainSummaryHtml + tableHtml;
            updateExportButtonVisibility(); // Ensure the export button is visible after rendering
        }

        // Renamed and modified function to populate only Month and Year
        function populateMonthYearSelector() {
            const selector = document.getElementById('monthYearSelector');
            selector.innerHTML = ''; // Clear existing options

            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            // Collect unique year-month combinations from globalResults
            const uniqueMonthYears = new Set(); // Stores as "YYYY-MM" (e.g., "2024-05")
            globalResults.forEach(r => {
                const {
                    year,
                    month
                } = getBKKTimeComponents(r.dateObject); // month is 0-indexed
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`); // Store as YYYY-MM
            });

            // Sort unique periods chronologically
            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();

            // Add 'All Data' option
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            selector.appendChild(allOption);

            // Add options for each unique month and year
            sortedUniqueMonthYears.forEach(periodStr => {
                const [yearStr, monthStr] = periodStr.split('-');
                const year = parseInt(yearStr);
                const month = parseInt(monthStr); // 1-indexed month

                const option = document.createElement('option');
                option.value = `${year}-${month.toString().padStart(2, '0')}`; // Value as "YYYY-MM"
                option.textContent = `${monthNames[month - 1]} ${year + 543}`; // Display as Thai month and Buddhist year
                selector.appendChild(option);
            });

            // Set the default selected month to the latest month available
            if (sortedUniqueMonthYears.length > 0) {
                // Find the latest billing period based on AR type
                // This logic might need refinement based on exact billing cycle definition
                // For simplicity, let's just pick the last month in the sorted list as default
                selector.value = sortedUniqueMonthYears[sortedUniqueMonthYears.length - 1];
            }
        }


        // Helper function to calculate billing period start and end dates
        function getBillingPeriodDates(selectedYear, selectedMonth, arType) {
            let billingPeriodStartDate, billingPeriodEndDate;

            // Determine the month and year for the *previous* reading
            let prevReadingMonth = selectedMonth - 1; // 1-indexed month
            let prevReadingYear = selectedYear;
            if (prevReadingMonth === 0) { // If current month is January, previous is December of last year
                prevReadingMonth = 12;
                prevReadingYear--;
            }

            // Determine the reading day for the previous month based on its number of days
            const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
            if (prevReadingDay === -1) {
                console.error(`[getBillingPeriodDates] Failed to get previous reading day for ${prevReadingYear}-${prevReadingMonth}`);
                return {
                    startDate: null,
                    endDate: null
                };
            }

            // Calculate the start date of the billing period
            // It's the previous month's reading date at 00:15:00 BKK (UTC components match BKK)
            billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay); // monthIndex is 0-indexed for getBKKMidnightUTCAdjusted
            billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


            // Determine the reading day for the *current* billing month based on its number of days
            const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
            if (currentReadingDay === -1) {
                console.error(`[getBillingPeriodDates] Failed to get current reading day for ${selectedYear}-${selectedMonth}`);
                return {
                    startDate: null,
                    endDate: null
                };
            }

            // Calculate the end date of the billing period
            // It's the current month's reading date at 00:00:00 BKK (of the *next* day) (UTC components match BKK)
            billingPeriodEndDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay); // monthIndex is 0-indexed


            return {
                startDate: billingPeriodStartDate,
                endDate: billingPeriodEndDate
            };
        }


        function updateDisplay() {
            if (!isProcessed) {
                return;
            }
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;

            console.log(`[updateDisplay] User selected Month/Year: ${selectedMonthYear}, AR Type: ${selectedArType}`);

            // New: Calculate and display billing period
            const billingPeriodInfoDiv = document.createElement('div');
            billingPeriodInfoDiv.className = 'summary-box billing-period-info';

            if (selectedMonthYear !== 'all') {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                const {
                    startDate,
                    endDate
                } = getBillingPeriodDates(selectedYearInt, selectedMonthInt, selectedArType);

                if (startDate && endDate) {
                    // LOG: Check calculated startDate and endDate.
                    // toISOString() always outputs in UTC, but since our dates are UTC-adjusted
                    // they will show the BKK-equivalent UTC time.
                    console.log(`[updateDisplay] Calculated Billing Period Start (UTC-adjusted BKK): ${startDate.toISOString()}`);
                    console.log(`[updateDisplay] Calculated Billing Period End (UTC-adjusted BKK): ${endDate.toISOString()}`);

                    const formatDateTime = (dateObj) => {
                        // This dateObj is already UTC-adjusted to represent BKK time.
                        // So, we directly read its UTC components.
                        const bkkComponents = {
                            year: dateObj.getUTCFullYear(),
                            month: dateObj.getUTCMonth(), // 0-indexed
                            day: dateObj.getUTCDate(),
                            hour: dateObj.getUTCHours(),
                            minute: dateObj.getUTCMinutes()
                        };
                        return `${bkkComponents.day.toString().padStart(2, '0')}/${(bkkComponents.month + 1).toString().padStart(2, '0')}/${bkkComponents.year + 543} ${bkkComponents.hour.toString().padStart(2, '0')}:${bkkComponents.minute.toString().padStart(2, '0')}:00`;
                    };

                    // Removed: displayEndDate.setUTCMilliseconds(displayEndDate.getUTCMilliseconds() - 1); // Go back 1 millisecond

                    billingPeriodInfoDiv.innerHTML = `
                        <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                        <p>‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà: <strong>${formatDateTime(startDate)}</strong></p>
                        <p>‡∏ñ‡∏∂‡∏á: <strong>${formatDateTime(endDate)}</strong></p>
                    `;
                } else {
                    console.warn("[updateDisplay] Could not calculate billing period dates for display.");
                }
            } else {
                // If "All Data" is selected, indicate that
                billingPeriodInfoDiv.innerHTML = `
                    <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                    <p>‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå</p>
                `;
            }

            // Clear previous billing period info and append the new one
            const outputDiv = document.getElementById('output');
            const existingBillingInfo = outputDiv.querySelector('.billing-period-info');
            if (existingBillingInfo) {
                existingBillingInfo.remove();
            }

            // Find the position after meter info but before the main summary
            const meterInfoBox = outputDiv.querySelector('.meter-info');
            if (meterInfoBox) {
                meterInfoBox.insertAdjacentElement('afterend', billingPeriodInfoDiv);
            } else {
                // Fallback if meter info box isn't found (shouldn't happen with current structure)
                outputDiv.prepend(billingPeriodInfoDiv);
            }

            renderResults(selectedUnit, selectedMonthYear, selectedArType);
        }

        async function process() {
            // *** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ***
            if (isProcessed) {
                console.log("File already processed. Skipping re-processing.");
                // ‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏≤‡∏à‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà ‡πÄ‡∏ä‡πà‡∏ô alert("‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß")
                return;
            }
            // **********************************

            collectHolidays();
            const file = excelFileInput.files[0];
            if (!file) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö/‡∏Ñ‡πà‡∏∞");
                return;
            }

            dropArea.innerHTML = `<span class="icon" style="color: #28a745;">‚úÖ</span><p>‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: <strong>${file.name}</strong></p><p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</p>`;
            document.getElementById('output').innerHTML = '<p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>';


            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {
                    type: 'array',
                    cellDates: true
                });
                const sheet = wb.Sheets[wb.SheetNames[0]];

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Excel
                // ‡∏≠‡πà‡∏≤‡∏ô header row ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå
                // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ header ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡πÅ‡∏ñ‡∏ß‡πÅ‡∏£‡∏Å (index 0) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
                // ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 3 (index 2) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°
                let startRowForData = 3; // Default for existing structure
                let rawDateCol, whCol, varhCol;
                let isCompactFormat = false;

                // Attempt to read headers from row 1 (0-indexed) for the compact format
                const headerRowCompact = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 'A1:C1' })[0];
                console.log("Header row for compact check:", headerRowCompact);

                if (headerRowCompact &&
                    headerRowCompact[0] === 'DATE_M' &&
                    headerRowCompact[1] === 'WH' &&
                    headerRowCompact[2] === 'VARHIMP Total') {

                    console.log("Detected compact format (3 columns).");
                    isCompactFormat = true;
                    startRowForData = 1; // Data starts from row 2 (index 1) for compact format
                    rawDateCol = 0; // Column A
                    whCol = 1;      // Column B
                    varhCol = 2;    // Column C

                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ meterNumber ‡πÅ‡∏•‡∏∞ multiplier ‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°
                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô N/A ‡∏´‡∏£‡∏∑‡∏≠ 0 ‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ
                    meterNumber = 'N/A (Compact File)';
                    multiplier = 1; // ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ô‡∏µ‡πâ
                } else {
                    console.log("Detected standard format.");
                    isCompactFormat = false;
                    startRowForData = 3; // Data starts from row 4 (index 3) for standard format
                    rawDateCol = 2;  // Column C
                    whCol = 26;      // Column AA
                    varhCol = 34;    // Column AI

                    if (sheet['A4'] && sheet['A4'].v !== undefined) {
                        meterNumber = sheet['A4'].v.toString();
                    } else {
                        meterNumber = 'N/A';
                    }

                    const e4 = parseFloat(sheet['E4'] ? sheet['E4'].v : 0);
                    const f4 = parseFloat(sheet['F4'] ? sheet['F4'].v : 0);
                    const g4 = parseFloat(sheet['G4'] ? sheet['G4'].v : 0);
                    const h4 = parseFloat(sheet['H4'] ? sheet['H4'].v : 0);

                    if (f4 !== 0 && h4 !== 0) {
                        multiplier = (e4 / f4) * (g4 / h4);
                    } else {
                        multiplier = 0;
                    }
                }


                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1
                });

                globalResults = [];
                isProcessed = false; // *** ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà ***

                for (let i = startRowForData; i < rows.length; i++) {
                    const rawDate = rows[i][rawDateCol];
                    const originalWhValue = parseFloat(rows[i][whCol]) || 0;
                    const originalVarhValue = parseFloat(rows[i][varhCol]) || 0;

                    if (!rawDate || isNaN(originalWhValue) || isNaN(originalVarhValue)) continue;

                    // *** ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô helper ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å Excel ***
                    let dateObjectBKK = convertExcelDateToBKKUTCAdjusted(rawDate);
                    if (!dateObjectBKK) continue; // ‡∏ñ‡πâ‡∏≤‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏° row ‡∏ô‡∏µ‡πâ‡πÑ‡∏õ

                    // Rounding to nearest 15-minute interval for dateObjectBKK (‡∏ã‡∏∂‡πà‡∏á‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô UTC-adjusted BKK ‡πÅ‡∏•‡πâ‡∏ß)
                    const totalMinutesFromBKKMidnight = dateObjectBKK.getUTCHours() * 60 + dateObjectBKK.getUTCMinutes() + dateObjectBKK.getUTCSeconds() / 60;
                    const roundedTotalMinutesBKK = Math.round(totalMinutesFromBKKMidnight / 15) * 15;

                    // Create the final roundedDateObjectUTC with the correct BKK time in its UTC components
                    const roundedDateObjectUTC = new Date(Date.UTC(
                        dateObjectBKK.getUTCFullYear(),
                        dateObjectBKK.getUTCMonth(),
                        dateObjectBKK.getUTCDate(),
                        0, // Start from midnight BKK (which is now in UTC components)
                        roundedTotalMinutesBKK,
                        0, 0
                    ));
                    // No additional setUTCHours adjustment needed here as the previous steps ensured
                    // that roundedDateObjectUTC has its UTC components representing the desired BKK time.

                    const displayBkkComponents = getBKKTimeComponents(roundedDateObjectUTC);
                    const formattedDatetime = `${displayBkkComponents.year}/${(displayBkkComponents.month + 1).toString().padStart(2, '0')}/${displayBkkComponents.day.toString().padStart(2, '0')} ${displayBkkComponents.hour.toString().padStart(2, '0')}:${displayBkkComponents.minute.toString().padStart(2, '0')}:00`;

                    globalResults.push({
                        datetime: formattedDatetime,
                        originalWhValue: originalWhValue,
                        originalVarhValue: originalVarhValue,
                        dateObject: roundedDateObjectUTC // This is the UTC-adjusted BKK time
                    });
                }

                isProcessed = true; // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô
                sortState.columnIndex = null;
                sortState.direction = 'asc';

                populateMonthYearSelector(); // Populate the Month/Year selector
                // Initial display
                updateDisplay();
            };
            reader.readAsArrayBuffer(file);
        }

        // Modified Export to Excel Function
        function exportTableToExcel() {
            if (!isProcessed) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å");
                return;
            }

            const unitType = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;


            let whUnit, varhUnit;
            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 3;

                whCalculation = (wh_val) => {
                    let baseKw = (parseFloat(wh_val) * 4 / 1000);
                    let roundedBaseKw = parseFloat(baseKw.toFixed(decimalPlaces));
                    if (applyMultiplier) {
                        return roundedBaseKw * currentMultiplier;
                    }
                    return roundedBaseKw;
                };
                varhCalculation = (varh_val) => {
                    let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                    let roundedBaseKvar = parseFloat(baseKvar.toFixed(decimalPlaces));
                    if (applyMultiplier) {
                        return roundedBaseKvar * currentMultiplier;
                    }
                    return roundedBaseKvar;
                };
            } else { // kWh, kVarh
                whUnit = 'kWh';
                varhUnit = 'kVarh';
                decimalPlaces = 2;

                const roundToDecimal = (value, decimals) => {
                    const factor = Math.pow(10, decimals);
                    return Math.round(value * factor) / factor;
                };

                whCalculation = (wh_val) => {
                    const raw = (parseFloat(wh_val) / 1000);
                    return roundToDecimal(raw * currentMultiplier, decimalPlaces);
                };

                varhCalculation = (varh_val) => {
                    const raw = (parseFloat(varh_val) / 1000);
                    return roundToDecimal(raw * currentMultiplier, decimalPlaces);
                };
            }

            const dataToExport = [];

            // Add header row
            dataToExport.push(['‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤', '‡πÄ‡∏£‡∏ó', whUnit, varhUnit]);

            let dataForExport = [];
            if (selectedMonthYear === 'all') {
                dataForExport = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                dataForExport = globalResults.filter(r => {
                    return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                });
            }

            // Apply sorting if a sort state is active (same as renderResults)
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh) => {
                        let baseKw = (parseFloat(wh) * 4 / 1000);
                        let roundedBaseKw = parseFloat(baseKw.toFixed(3));
                        if (applyMultiplierForSort) return roundedBaseKw * currentMultiplierForSort;
                        return roundedBaseKw;
                    };
                    varhUnitConverterForSort = (varh) => {
                        let baseKvar = (parseFloat(varh) * 4 / 1000);
                        let roundedBaseKvar = parseFloat(baseKvar.toFixed(3));
                        if (applyMultiplierForSort) return roundedBaseKvar * currentMultiplierForSort;
                        return roundedBaseKvar;
                    };
                } else {
                    whUnitConverterForSort = (wh) => (parseFloat(wh) / 1000) * currentMultiplierForSort;
                    varhUnitConverterForSort = (varh) => (parseFloat(varh) / 1000) * currentMultiplierForSort;
                }

                dataForExport.sort((a, b) => { // Sort dataForExport, not filteredResults
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            // Add data rows
            dataForExport.forEach(r => {
                // Add this check to ensure 'r' and 'r.dateObject' are valid
                if (!r || !r.dateObject) {
                    console.error("Skipping malformed data row during export:", r);
                    return; // Skip this iteration if the data is not as expected
                }

                const wh = r.originalWhValue || 0;
                const varh = r.originalVarhValue || 0;

                // --- ‡πÄ‡∏û‡∏¥‡πà‡∏° console.log ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö wh Calculation ‡πÉ‡∏ô export ---
                console.log(`--- Export WH Calculation for Datetime: ${r.datetime} ---`);
                console.log(`Raw WH value: ${wh}`);

                const currentWhBeforeMultiplier = (unitType === 'kw_kvar') ? (parseFloat(wh) * 4 / 1000) : (parseFloat(wh) / 1000);
                console.log(`WH value after initial conversion (before multiplier) for export: ${currentWhBeforeMultiplier.toFixed(decimalPlaces)}`);

                const currentWh = whCalculation(wh);
                console.log(`WH value after multiplier (final export): ${currentWh.toFixed(decimalPlaces)}`);
                // ---------------------------------------------------------

                const currentVarh = varhCalculation(varh);

                const rate = getRate(r.dateObject);

                dataToExport.push([
                    r.datetime,
                    rate,
                    currentWh.toFixed(decimalPlaces),
                    currentVarh.toFixed(decimalPlaces)
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(dataToExport);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Electric Rates Filtered");

            const filename = `Electric_Rates_${selectedMonthYear}_${selectedArType}_${new Date().toISOString().slice(0, 10)}.xlsx`;

            XLSX.writeFile(wb, filename);
        }

        document.getElementById('exportExcel').addEventListener('click', exportTableToExcel);
    </script>
</body>

</html>